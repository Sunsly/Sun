#  <#Title#>
https://juejin.im/post/5b56155e6fb9a04f8b78619b

1.无痕埋点 App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？
    
    **1代码埋点
        由开发人员 在触发事件的具体方法中 植入代码把需要的参数传送到服务端
    **2可视化埋点
        h根据标识 来识别每一个事件，针对指定的事件进行取参埋点 而事件的标识与参数信息都写在配置表中，通过动态下发配置表来实现埋点统计
    **3无痕埋点 (将埋点代码从业务代码中剥离，放到独立的模块中的技术)AOP 全称叫 Aspect-Oriented Programming，中文名叫面向切面编程
        无埋点并不是不需要埋点，更准确的说应该是“全埋”， 前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。 通过定期上传记录文件，配合文件解析，解析出来我们想要的数据， 并生成可视化报告供专业人员分析 ， 因此实现“无埋点”统计
        它并不是真正的不需要埋点，而是前端自动采集全部事件并上报埋点数据，在后端数据计算时过滤出有用数据，代表方案是国内的GrowingIO
    **总结来说 无痕埋点 就是 前端自动采集全部事件并上报埋点数据，在后端数据计算时过滤出有用数据
    在不同场景下我们需要选择不同的埋点方案。例如对于简单的用户行为类事件，可以使用无痕埋点解决；而对于需要携带大量运行时才可获知的业务字段的埋点需求，就需要声明式埋点来解决。从更高的层面来看
        
2.有哪些情况会导致app卡顿，分别可以用什么方法来避免

    **分cpu卡和gpu卡顿。
    
    一、优化CPU
        *主线程耗时操作   ->可以多线程操作 尽量把耗时的操作放到子线程
        *滑动页面渲染卡顿 （离屛渲染）
        * 线程太多卡死 - > 控制一下线程的最大并发数量
        *不要频繁地调用 UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改
        *尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
            Autolayout会比真设置frame消耗更多的CPU资源
        *图片的size最好刚好好UIImageView的size保持一致
     二、优化GPU  
     
        *尽量减少视图数量和层次
        *尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显
        *GPU能处理的最大纹理尺寸是4096*4096，一旦超过这个尺寸，就会占有用CPU资源进行处理，所以纹理尽量不要超过这个尺寸
        *减少透明的视图，不透明的就设置 opaque 为yes
        *尽量避免出现离屏渲染
    三、卡顿检测
    
        卡顿，主要因为在主线程执行了耗时操作
        可以添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的
        这是一个用来监听卡顿的工具包：
        https://github.com/UIControl/LXDAppFluecyMonitor
        
    四、耗电优化
    
        少用定时器
        优化IO操作
        不要频繁写入小数据，最好批量一次性写入
    
3.你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？

    **NSInvalidArgumentException 异常
    **SIGSEGV是当SEGV发生的时候，让代码终止的标识。 当去访问没有被开辟的内存或者已经被释放的内存时，就会发生这样的异常。另外，在低内存的时候，也可能会产生这样的异常
    ** NSRangeException 异常
        造成这个异常，就是越界异常了，在iOS中我们经常碰到的越界异常有两种，一种是数组越界，一种字符串截取越界
     ** SIGABRT 异常 这是一个让程序终止的标识，会在断言、app内部、操作系统用终止方法抛出。通常发生在异步执行系统方法的时候。如CoreData、NSUserDefaults等，还有一些其他的系统多线程操作
     
     向容器加入nil，引起的崩溃。hook容器添加方法，进行判断
4.App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下,）

    优化pre-mainj阶段 
        1.删除无用代码 （未被调用的静态变量、类和方法）
        （未使用的本地变量、未使用的参数、未使用的值）
        2.抽象重复代码删除
        3.不宜在+load中做f更多的操作
        4.减少不必要的framework 或者优化已有的framework
    main阶段优化
        首次启动渲染的页面优化
        1、不使用xib或者storyboard，直接使用代码；
        2、对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做，或者采用异步的方式去做；
        3、当首页逻辑比较复杂的时候，建议CD冷却放大招：通过instruments的Time Profiler分析耗时瓶颈。
        
    https://www.jianshu.com/p/0615138f9f19

    
5.有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点

        设置优先级 设置并发数 ，设置任务的依赖关系 面向对象

6.反射是什么？可以举出几个应用场景么？

    就是将两个对象的所有属性，用动态的方式取出来，并根据属性名，自动绑值
    注意：对象的类，如果是派生类，就得靠其他方式来实现了，因为得到不该基类的属性。）
      运行时选择创建哪个实例，并动态选择调用哪个方法
      
      ** 优点   松耦合，类与类之间不需要太多依赖  构建灵活
      ** 缺点  不利于维护。使用反射模糊了程序内部实际发生的事情，隐藏了程序的逻辑。这种绕过源码的方式比直接代码更为复杂，增加了维护成本。性能较差。使用反射匹配字符串间接命中内存比直接命中内存的方式要慢
      
7.AppDelegate如何瘦身？

    ** 给appdelegate 创建类别
    ** 组件化设计 (SOA面向服务的架构)

8：对一个数组去重有哪些方法？

    数据循环比较去重
    通过集合NSSet去重
    通过字典NSDictionary去重
    利用keyValue去重
9：UITableView的优化机制有哪些 ？

tableView的优化主要涉及的是cell的重用机制，视图渲染原理及CPU和GPU的工作原理。

10：本地化数据存储你用过哪些？查询两个表的同一个字段的数据Sql怎么写？去重的sql怎么写？

11：如何在block内部修改外部局部变量的值？为什么？

12：在滑动页面时，定时器卡顿如何解决？

13：KVO是什么？

14：页面卡顿原理是什么？如何解决？

15：在C语言中如何定义一个类？OC语言是如何转化为C语言的面向过程的呢？

16：iOS11有哪些特性？

17：你是怎么理解HTTPS的？延伸到对称加密和非对称加密，建立连接过程和数据请求部分。

18：NSOperationQueue实现了什么？和GCD的区别。

19：__weak和__block有什么区别？

20：[[[objc method1] method2] method3：[objc method4]]这些方法的调用顺序是怎样的？

21: NSTimer *timer = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:self selector:@selector(fireTimer) userInfo:nil repeats:NO];
                [timer fire];
                                    timer为什么无效？
                                                                
22: [UIImage imageNamed:@""];
     [UIImage imageWithContentsOfFile:@""];
    这两个方法有什么区别？
 23：OC中有私有方法和私有变量吗？

******************网络题****************
24.App 网络层有哪些优化策略？

    总结：优化DNS解析和缓存
    网络质量检测
    提供网络服务优先级和依赖机制
    提供网络服务重发机制
    减少数据传输量
    优化海外网络性能
    实践：每个网络绑定到vc，vc销毁，网络层销毁
    数据请求优先级高于图片请求，网络层做区分
    
25.tcps为什么要三次握手，四次挥手？
    
    关于tcp三次握手 ，四次挥手
    第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
    
    第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
    
    第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
    
    连接终止协议（四次握手）
    
    第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。
    
    第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号， SYN 和 FIN 都有seq序号）。
    第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手
    
    
    【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？
    
    答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
    
    【问题3】为什么不能用两次握手进行连接？
    
    答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
    【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？
    
    TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
    
    
    SYN(synchronous建立联机)
    ACK(acknowledgement 确认)
    PSH(push传送)
    FIN(finish结束)
    RST(reset重置)
    URG(urgent紧急)
    Sequence number(seq 顺序号码)
    Acknowledge number(ack 确认号码)
   
 26  对称加密和非对称加密的区别？分别有哪些算法的实现？
 
 
 
        
********************
//安装 fui 工具 在终端中执行命令
sudo gem install fui -n /usr/local/bin

fui usage: https://github.com/dblock/fui

到工程目录下，执行 fui find 命令，可以找出所有的没有用到的class文件
**查找无用图片
https://github.com/tinymind/LSUnusedResources

#  <#Title#>
https://juejin.im/post/5b56155e6fb9a04f8b78619b

1.无痕埋点 App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？
    
    **1代码埋点
        由开发人员 在触发事件的具体方法中 植入代码把需要的参数传送到服务端
    **2可视化埋点
        h根据标识 来识别每一个事件，针对指定的事件进行取参埋点 而事件的标识与参数信息都写在配置表中，通过动态下发配置表来实现埋点统计
    **3无痕埋点 (将埋点代码从业务代码中剥离，放到独立的模块中的技术)AOP 全称叫 Aspect-Oriented Programming，中文名叫面向切面编程
        无埋点并不是不需要埋点，更准确的说应该是“全埋”， 前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。 通过定期上传记录文件，配合文件解析，解析出来我们想要的数据， 并生成可视化报告供专业人员分析 ， 因此实现“无埋点”统计
        它并不是真正的不需要埋点，而是前端自动采集全部事件并上报埋点数据，在后端数据计算时过滤出有用数据，代表方案是国内的GrowingIO
    **总结来说 无痕埋点 就是 前端自动采集全部事件并上报埋点数据，在后端数据计算时过滤出有用数据
    在不同场景下我们需要选择不同的埋点方案。例如对于简单的用户行为类事件，可以使用无痕埋点解决；而对于需要携带大量运行时才可获知的业务字段的埋点需求，就需要声明式埋点来解决。从更高的层面来看
        
2.有哪些情况会导致app卡顿，分别可以用什么方法来避免

    **分cpu卡和gpu卡顿。
    
    一、优化CPU
        *主线程耗时操作   ->可以多线程操作 尽量把耗时的操作放到子线程
        *滑动页面渲染卡顿 （离屛渲染）
        * 线程太多卡死 - > 控制一下线程的最大并发数量
        *不要频繁地调用 UIView的相关属性，比如frame、bounds、transform等属性，尽量减少不必要的修改
        *尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
            Autolayout会比真设置frame消耗更多的CPU资源
        *图片的size最好刚好好UIImageView的size保持一致
     二、优化GPU  
     
        *尽量减少视图数量和层次
        *尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显
        *GPU能处理的最大纹理尺寸是4096*4096，一旦超过这个尺寸，就会占有用CPU资源进行处理，所以纹理尽量不要超过这个尺寸
        *减少透明的视图，不透明的就设置 opaque 为yes
        *尽量避免出现离屏渲染
    三、卡顿检测
    
        卡顿，主要因为在主线程执行了耗时操作
        可以添加Observer到主线程RunLoop中，通过监听RunLoop状态切换的耗时，以达到监控卡顿的目的
        这是一个用来监听卡顿的工具包：
        https://github.com/UIControl/LXDAppFluecyMonitor
        
    四、耗电优化
    
        少用定时器
        优化IO操作
        不要频繁写入小数据，最好批量一次性写入
    
3.你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？

    **NSInvalidArgumentException 异常
    **SIGSEGV是当SEGV发生的时候，让代码终止的标识。 当去访问没有被开辟的内存或者已经被释放的内存时，就会发生这样的异常。另外，在低内存的时候，也可能会产生这样的异常
    ** NSRangeException 异常
        造成这个异常，就是越界异常了，在iOS中我们经常碰到的越界异常有两种，一种是数组越界，一种字符串截取越界
     ** SIGABRT 异常 这是一个让程序终止的标识，会在断言、app内部、操作系统用终止方法抛出。通常发生在异步执行系统方法的时候。如CoreData、NSUserDefaults等，还有一些其他的系统多线程操作
     
     向容器加入nil，引起的崩溃。hook容器添加方法，进行判断
4.App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下,）

    优化pre-mainj阶段 
        1.删除无用代码 （未被调用的静态变量、类和方法）
        （未使用的本地变量、未使用的参数、未使用的值）
        2.抽象重复代码删除
        3.不宜在+load中做f更多的操作
        4.减少不必要的framework 或者优化已有的framework
    main阶段优化
        首次启动渲染的页面优化
        1、不使用xib或者storyboard，直接使用代码；
        2、对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做，或者采用异步的方式去做；
        3、当首页逻辑比较复杂的时候，建议CD冷却放大招：通过instruments的Time Profiler分析耗时瓶颈。
        
    https://www.jianshu.com/p/0615138f9f19

    
5.有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点

        设置优先级 设置并发数 ，设置任务的依赖关系 面向对象

6.反射是什么？可以举出几个应用场景么？

    就是将两个对象的所有属性，用动态的方式取出来，并根据属性名，自动绑值
    注意：对象的类，如果是派生类，就得靠其他方式来实现了，因为得到不该基类的属性。）
      运行时选择创建哪个实例，并动态选择调用哪个方法
      
      ** 优点   松耦合，类与类之间不需要太多依赖  构建灵活
      ** 缺点  不利于维护。使用反射模糊了程序内部实际发生的事情，隐藏了程序的逻辑。这种绕过源码的方式比直接代码更为复杂，增加了维护成本。性能较差。使用反射匹配字符串间接命中内存比直接命中内存的方式要慢
      
7.AppDelegate如何瘦身？

    ** 给appdelegate 创建类别
    ** 组件化设计 (SOA面向服务的架构)

8：对一个数组去重有哪些方法？

    数据循环比较去重
    通过集合NSSet去重
    通过字典NSDictionary去重
    利用keyValue去重
9：UITableView的优化机制有哪些 ？

tableView的优化主要涉及的是cell的重用机制，视图渲染原理及CPU和GPU的工作原理。

10：本地化数据存储你用过哪些？查询两个表的同一个字段的数据Sql怎么写？去重的sql怎么写？

11：如何在block内部修改外部局部变量的值？为什么？

12：在滑动页面时，定时器卡顿如何解决？

13：KVO是什么？

14：页面卡顿原理是什么？如何解决？

15：在C语言中如何定义一个类？OC语言是如何转化为C语言的面向过程的呢？

16：iOS11有哪些特性？

17：你是怎么理解HTTPS的？延伸到对称加密和非对称加密，建立连接过程和数据请求部分。

18：NSOperationQueue实现了什么？和GCD的区别。

19：__weak和__block有什么区别？

20：[[[objc method1] method2] method3：[objc method4]]这些方法的调用顺序是怎样的？

21: NSTimer *timer = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:self selector:@selector(fireTimer) userInfo:nil repeats:NO];
                [timer fire];
                                    timer为什么无效？
                                                                
22: [UIImage imageNamed:@""];
     [UIImage imageWithContentsOfFile:@""];
    这两个方法有什么区别？
 23：OC中有私有方法和私有变量吗？

******************网络题****************
24.App 网络层有哪些优化策略？

    总结：优化DNS解析和缓存
    网络质量检测
    提供网络服务优先级和依赖机制
    提供网络服务重发机制
    减少数据传输量
    优化海外网络性能
    实践：每个网络绑定到vc，vc销毁，网络层销毁
    数据请求优先级高于图片请求，网络层做区分
    
25.tcps为什么要三次握手，四次挥手？
    
    关于tcp三次握手 ，四次挥手
    第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
    
    第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
    
    第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
    
    连接终止协议（四次握手）
    
    第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。
    
    第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号， SYN 和 FIN 都有seq序号）。
    第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
    第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手
    
    
    【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？
    
    答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
    
    【问题3】为什么不能用两次握手进行连接？
    
    答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
    【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？
    
    TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
    
    
    SYN(synchronous建立联机)
    ACK(acknowledgement 确认)
    PSH(push传送)
    FIN(finish结束)
    RST(reset重置)
    URG(urgent紧急)
    Sequence number(seq 顺序号码)
    Acknowledge number(ack 确认号码)

 26  对称加密和非对称加密的区别？分别有哪些算法的实现？
        
        对称加密
        对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥加密
                 也就是密钥也可以用作解密密钥，这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的加密性好，而且对计算机功能要求也没有那么高
                 常见的对称加密算法有DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和AES
                 
                 优点：算法公开、计算量小、加密速度快、加密效率高。
                 缺点：秘钥的管理和分发非常困难，不够安全。在数据传送前，发送方和接收方必须商定好秘钥，然后双方都必须要保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。
                 非对称加密
                 什么是非对称加密技术
                 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。
                 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
                 常见的非对称加密算法有：RSA、ECC（椭圆曲线加密算法,移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）
                 优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。
                 缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
                 我们常见的数字证书、加密狗即是采用非对称加密来完成安全验证的。
                 
                 
                 
                 */
                 
                 //Hash算法（摘要算法）
                 /*
                 Hash算法（摘要算法）
                 
                 Hash算法特别的地方在于它是一种单向算法，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。
                 
                 常见的Hash算法有MD2、MD4、MD5、HAVAL、SHA
   
  *****************计算机系统题
 27.了解编译的过程么？分为哪几个步骤？
 
      编译语言 和 直译式语言
      c c++ oc 都是编译语言  编译的时候必须先通过编译器c生成机器语言  机器码可以直接在CPU上执行，所以执行效率较高
   oc swift   编译都是依赖于Clang + LLVM. 
   采用Calang 作为q编译器 前端  LLVM作为编译器后端 LLVM机器码生成器会针对不同的架构， arm64等生成不同的机器码
      
 28 静态链接了解么？静态库和动态库的区别？
        预编译 - 编译 - 汇编 - 链接
       
     1.静态链接与动链接的区别
      在C语言中，我们知道要生成可执行文件，必须经历两个阶段，即编译、链接。
             
         在编译过程中，只有编译，不会涉及到链接。
       在链接过程中，静态链接和动态链接就出现了区别。静态链接的过程就已经把要链接的内容已经链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；而动态链接这个过程却没有把内容链接进去，而是在执行的过程中，再去找要链接的内容，生成的可执行文件中并没有要链接阿的内容，所以当你删除动态库时，可执行程序就不能运行。                  
        所以总的来说，动态链接生成的可执行文件要比静态链接生成的文件要小一些。
        2.动态库与静态库的区别
         2.1就不设置环境变量的情况下来说
                动态库一般都会存在/usr/lib/ 目录下；而静态库可以在任何目录下，只要你第一次链接的时候，用绝对路径去链接就行了，之后再删除，是不会影响你的生成的执行文件的。    
        2.2如若可以设置环境变量的话            
                动态库和静态库可以放置到你想放的任何地方，只是动态库需要设置环境变量，而静态库链接的时候需要绝对路径。                      
                  但一般来说，动态库都会放在放在/usr/lib，应该大家都习惯了，这样也方便寻找，而当链接动态库的时候默认的路径就是/usr/lib。
          ***********动态库在内存中只存在一份拷贝，避免了静态库浪费资源空间的问题
          
 29 内存的几大区域，各自的职能分别是什么？
 
        *栈区stack  由编译器自动分配释放 管理，存放函数的参数值，局部变量，栈是系统数据结构d，对应线程、进程是惟一的，优点：快速高速，缺点：有限制，数据不灵活，先进后出
            栈空间分 静态分配和动态分配
             静态分配 ，是有编译器完成的 ，比如自动变量的分配
             栈动态分配 是由alloca函数完成， 栈的动态分配无需释放
          *堆区 heap由程序员分配和释放，如果程序员不释放，程序结束时，j会由系统回收，
            优点：灵活方便，应用广泛，但效率略低 
          *全局区（静态存储区static）全局变量 和 静态变量 的存储放在一起的，初始化的全局变量
         和静态变量存放在一块区域，未初始化的全局变量和静态变量存放在另一区域，程序结束后由系统h回收释放
        *文字常量区 ，存放常量字符串，程序结束后由系统释放
       *代码区  存放函数代码 
 30 static和const有什么区别？
 

    static 局部变量，将一个变量声明为函数的局部变量，name那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中
    static 全局变量 表示一个变量在当前文件的全局内可访问
    static 函数 表示一个函数只能在当前文件中被访问
    static 类成员变量 表示这个成员为全类所共有
    static 类成员函数 表示这个函数为全类所共有，而且只能访问静态成员变量
    
    const const 常量：定义时就初始化，以后不能更改
    const 形参：func(const int a){};该形参在函数里不能改变
    const修饰类成员函数：该函数对成员变量只能进行只读操作
    
    static 作用 
    在函数体内的static变量作用范围是a函数体，在内存中只被分配过一次，下次使用还是上次的值
    模块内的static全局变量和函数可以被模块内的函数访问，但不能被模块外其它函数访问
    类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
    const作用
    防止b一个变量被改变
    声明常量指针和指针常量
    const修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
    对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
    对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”。
 31. 内联函数 （代替宏）

     内联函数 是为了解决函数调用效率的问题
     由于函数之间的调用,会从一个内存地址调用到另外一个内存地址,当函数调用完毕之后还会返回原来函数执行的地址,函数调用会有一定的时间开销,引入内联函数是为了解决这一问题
     ***与普通函数区别
     不管是OC还是C/C++最终都需要编译成汇编指令，才能真正执行。普通函数在被调用的时候需要CPU执行CALL指令不同（需要完成程序计数器压栈->执行要执行的函数语句->出栈程序计数器），内联函数不需要这个调用过程，内联函数在编译的时候，会直接在需要执行内联函数的地方（普通函数执行CALL的汇编语句处）将内联函数的汇编片段copy一份并插入到此处，代替CALL指令（类似于宏定义），而不需要普通函数的CALL指令调用过程。因此内联函数的执行效率是比较高的，但是由于copy代码片段，需要内存消耗，所以内联函数是一种以空间换时间的方法
     ***与宏定义的区别
     内联函数在编译时展开，宏在预编译时展开
     内联函数直接嵌入到目标代码中，宏是简单的做文本替换
     inline函数是函数，宏不是
     宏定义只是简单的字符串替换，是不能做类型检查，内联函数相比而言就会更加安全
     宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义
     ***内联函数使用的注意项
     内联函数通常都是比较简单的代码片段，不能包含循环，递归（递归函数的内联扩展可能引起部分编译器的无穷编译）等的复杂流程，代码最好不要超过5行
     ***推荐使用内联函数代替宏定义
     YYKit，AFNetworking等一些优秀的三方框架中就有大量的静态（文件内使用）内联函数使用static inline
   32.什么时候会出现死锁？如何避免？
   
        死锁产生的条件
            *互斥；资源x的任意一个时刻只能被一个线程持有
            *占有且等待；线程1占有x资源x的同时等待资源y，并不释放x
            *不可抢占；资源x一旦被线程1占有，其他线程不能抢占
            *循环等待；线程1持有x，等待y，线程2持有y，等待x
         当全部满足是才会死锁
        如何避免
        避免是指进程在每次申请资源时判断这些操作是否安全
        死锁的避免主要有如下三大技术措施：
        加锁顺序：保证所有的线程的加锁顺序一致；
        加锁时限：给锁加一个时限，超时则自动释放；
        死锁检测：给锁做记录，当获取不到时先检测一下，如果死锁则回退并释放所有锁。
33.说一说你对线程安全的理解？
34.列举你知道的线程同步策略？
35.有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说


36.除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下

37.最喜欢哪个设计模式？为什么？

38.iOS SDK 里面有哪些设计模式的实践？

39.**设计模式是为了解决什么问题的？

40.**设计模式的成员构成以及工作机制是什么？

41.**设计模式的优缺点是什么？
       
 
 
 
 
 
********************
//安装 fui 工具 在终端中执行命令
sudo gem install fui -n /usr/local/bin

fui usage: https://github.com/dblock/fui

到工程目录下，执行 fui find 命令，可以找出所有的没有用到的class文件
**查找无用图片
https://github.com/tinymind/LSUnusedResources
